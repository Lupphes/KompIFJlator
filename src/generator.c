/*File name: generator.c---------------------------------------------*
 |Project:    Implementace překladače imperativního jazyka IFJ20     |
 |Team:       124, varianta II                                       |
 |Authors:    Viktor Rucký (xrucky01)                                |
 |                                                                   |
 |  _      _     _   __                   __  _        _             |
 | | |    (_)   | | /_/                  /_/ | |      | |            |
 | | |     _  __| | ___   _   _  __   ___   _| |_ __ _| |__  _   _   |
 | | |    | |/ _` |/ _ \ | | | | \ \ / / | | | __/ _` | '_ \| | | |  |
 | | |____| | (_| |  __/ | |_| |  \ V /| |_| | || (_| | | | | |_| |  |
 | |______|_|\__,_|\___|  \__,_|   \_/  \__, |\__\__,_|_| |_|\__,_|  |
 |                                       __/ |                       |
 |                                      |___/                        |
 *-------------------------------------------------------------------*/


#include "generator.h"

/**
 *	@brief	Generates the whole tree
 *
 *	@param	root	Root of the tree
 * 
 *	@return	SUCCESS 	If generating successful
 *	@return	INTERNAL_ERROR 	IF parameter root = NULL
 */
int generateTree(ASTRoot *root){
	if( root == NULL){
		fprintf(stderr, "ERROR!!! ROOT = NULL\n");
		return INTERNAL_ERROR;
	}

	printf("# Generated by KompIFJlator made by team 124 (Teamleader Ondřej Sloup xsloup02)\n");
	printf(".IFJcode20\n");
	printf("JUMP main\n");
	printf("#--------------- user funtions ---------------#\n");

	generateUserFunctions(root->userFunctions);
	generateMain(root->mainFunction);

	return SUCCESS;
}

/**
 *	@brief	Generates main function of given program
 *
 * 	@param	function 	Pointer to the function
 *
 *	@return	SUCCESS			If generating was successful
 *	@return	INTERNAL_ERROR	If param function is NULL and main does not exist
 */
int generateMain(ASTNodeFunction *function){
	if(function == NULL){
		fprintf(stderr, "missing main\n");
		return INTERNAL_ERROR;
	}

	printf("\n#------------------- main --------------------#\n");
	printf("\tLABEL main\n");
	printf("CREATEFRAME\n");
	printf("PUSHFRAME\n\n");

	generateFunctionBody(function);

	printf("\nPOPFRAME\n");
	printf("CREATEFRAME\n");
	printf("EXIT int@0\n");
	//generateDebug();

	return SUCCESS;
}

/**
 *	@brief	Generates all user functions by walking through linked list of functions
 *
 * 	@param	function 	Pointer to the first function
 */
void generateUserFunctions(ASTNodeFunction *function){
	while(function != NULL){
		// generate label + initial frame
		printf("\tLABEL %s\n", strGetStr(&function->function->id));
		printf("CREATEFRAME\n");
		printf("PUSHFRAME\n\n");

		// generate function body
		generateFunctionBody(function);

		// move to the next function
		function = function->next;
	}
}

// Generates function body. Param function guaranteed to NOT be NULL.
void generateFunctionBody(ASTNodeFunction *function){
	// Generate Definitions Of Variables
	printf("\n# Define all variables of function.\n");

	for(int i = 0; i < function->variables.count; i++){
		if(function->variables.arr[i] != NULL){
			char name[4096];
			generateVariableName(function->variables.arr[i], name);
			printf("DEFVAR %s\n", name);
		}
	}

	// generate function code block
	generateFunctionCodeBlock(function->code);
}

// Generate code blocK of the function
void generateFunctionCodeBlock(ASTNodeBlock* code){
	printf("\n# Code of this function.\n");
	printf("WRITE string@I'm\\032still\\032here!\\010\n");
}

// Generate functioncall
void generateFunctionCall(ASTNodeStatement *functionCall){
	//Až bude funkce generateFunctionCall, tak se skočí do generateBuiltInFunctionCall, 
	//pozná se, co to je za funkce a zavolá se správná obslužná funkce.

	/*
	foo, bar = returns2(5, foo, ":)")

	PUSHS int@5
	PUSHS LF@0
	PUSHS string@:)
	CALL returns2
	POPFRAME       printf("\nPOPFRAME\n"); // uklízí volající
	POPS LF@1
	POPS LF@0
	*/
}

// Generate variable name to format "LF@$uid"
char* generateVariableName(const SymbolVariable* var, char* out){
	int len = var->type != TypeBlackHole ? sprintf(out,"LF@$%d",var->uid) : sprintf(out,"nil@nil");
    if (len < 0)
        exit(INTERNAL_ERROR);
    return out + len;
}

// Generate debug instruction to ifjcode output
void generateDebug(){
	printf("WRITE string@-------\\010\n");
	printf("BREAK\n");
	printf("WRITE string@-------\\010\n");
}


/* Alpatron: 

generateBuiltInPrint, 

generateIntLiteral, 
generateFloatLiteral, 
generateStringLiteral, 
generateTermRepresentation

*/
